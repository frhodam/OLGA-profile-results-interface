# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test_slider.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import pyfas as fa
import pandas as pd
import numpy as np
import time as tm
import os, pprint, re, openpyxl, sys, queue
from openpyxl.chart import (ScatterChart, Reference, Series)
from openpyxl.styles import Font, Alignment
from openpyxl.utils import get_column_letter
from datetime import datetime
from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.setFixedSize(628, 555)
        font = QtGui.QFont()
        font.setPointSize(9)
        MainWindow.setFont(font)
        
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        MainWindow.setCentralWidget(self.centralwidget)
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(10, 30, 81, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")

        # Add menu bar
        
        self.menuBar = QtWidgets.QMenuBar(MainWindow)
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 628, 20))
        self.menuBar.setObjectName("menuBar")

        self.fileMenu = QtWidgets.QMenu(self.menuBar)
        self.fileMenu.setObjectName("fileMenu")
        self.helpMenu = QtWidgets.QMenu(self.menuBar)
        self.helpMenu.setObjectName("helpMenu")

        self.saveTempMenu = QtWidgets.QAction(MainWindow)
        self.saveTempMenu.setObjectName("saveTempMenu")
        self.howTo = QtWidgets.QAction(MainWindow)
        self.howTo.setObjectName("howTo")
        self.fileMenu.addAction(self.saveTempMenu)
        self.helpMenu.addAction(self.howTo)
        self.menuBar.addAction(self.fileMenu.menuAction())
        self.menuBar.addAction(self.helpMenu.menuAction())
        self.saveTempMenu.setEnabled(False)
        self.saveTempMenu.triggered.connect(self.saveTemplate)
        self.helpMenu.triggered.connect(self.howToUse)
        
        self.pathEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.pathEdit.setGeometry(QtCore.QRect(90, 30, 431, 21))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pathEdit.setFont(font)
        self.pathEdit.textChanged.connect(self.enablePathButton)
        self.pathEdit.setObjectName("pathEdit")

        # Display file button initially disabled        
        self.pathButton = QtWidgets.QPushButton(self.centralwidget)
        self.pathButton.setGeometry(QtCore.QRect(530, 30, 86, 23))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pathButton.setFont(font)
        self.pathButton.setObjectName("pathButton")
        self.pathButton.setEnabled(False)
        self.pathButton.clicked.connect(self.clickPathButton)
        
        self.displayFile = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.displayFile.setGeometry(QtCore.QRect(10, 90, 511, 61))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.displayFile.setFont(font)
        self.displayFile.setReadOnly(True)
        self.displayFile.setObjectName("displayFile")
        
        self.readingFileLabel = QtWidgets.QLabel(self.centralwidget)
        self.readingFileLabel.setGeometry(QtCore.QRect(10, 70, 131, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.readingFileLabel.setFont(font)
        self.readingFileLabel.setObjectName("readingFileLabel")
        
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(10, 190, 131, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        
        self.displayIndex = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.displayIndex.setGeometry(QtCore.QRect(10, 210, 511, 71))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.displayIndex.setFont(font)
        self.displayIndex.setReadOnly(True)
        self.displayIndex.setObjectName("displayIndex")

        # Select index button is disabled until indexEdit is filled        
        self.selectIndexButton = QtWidgets.QPushButton(self.centralwidget)
        self.selectIndexButton.setGeometry(QtCore.QRect(530, 300, 86, 21))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.selectIndexButton.setFont(font)
        self.selectIndexButton.setObjectName("selectIndexButton")
        self.selectIndexButton.setEnabled(False)
        self.selectIndexButton.clicked.connect(self.clickSelectIndexButton)
        
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(10, 300, 111, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.label_4.setFont(font)
        self.label_4.setObjectName("label_4")

        # Editing is disabled until folder path is inputed
        self.indexEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.indexEdit.setGeometry(QtCore.QRect(120, 300, 401, 21))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.indexEdit.setFont(font)
        self.indexEdit.setReadOnly(True)
        self.indexEdit.textChanged.connect(self.enableSelectIndex)
        self.indexEdit.setObjectName("indexEdit")
        
        self.displayStatus = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.displayStatus.setGeometry(QtCore.QRect(10, 430, 511, 101))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.displayStatus.setFont(font)
        self.displayStatus.setReadOnly(True)
        self.displayStatus.setObjectName("displayStatus")

        # Extract button is disabled until display status is filled       
        self.extractButton = QtWidgets.QPushButton(self.centralwidget)
        self.extractButton.setGeometry(QtCore.QRect(530, 430, 86, 21))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.extractButton.setFont(font)
        self.extractButton.setObjectName("extractButton")
        self.extractButton.setEnabled(False)
        self.extractButton.clicked.connect(self.clickExtractButton)

        # Export button is disabled until extraction is finished
        self.exportButton = QtWidgets.QPushButton(self.centralwidget)
        self.exportButton.setGeometry(QtCore.QRect(530, 460, 86, 21))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.exportButton.setFont(font)
        self.exportButton.setEnabled(False)
        self.exportButton.setObjectName("exportButton")
        self.exportButton.clicked.connect(self.clickExportButton)
        
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(10, 160, 131, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")

        # Editing is disabled until folder path is inputed
        self.variableEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.variableEdit.setGeometry(QtCore.QRect(120, 160, 401, 21))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.variableEdit.setFont(font)
        self.variableEdit.setReadOnly(True)
        self.variableEdit.textChanged.connect(self.enableFilterIndex)
        self.variableEdit.setObjectName("variableEdit")

        # Filter index button is disabled until variableEdit is filled
        self.filterIndexButton = QtWidgets.QPushButton(self.centralwidget)
        self.filterIndexButton.setGeometry(QtCore.QRect(530, 160, 86, 23))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.filterIndexButton.setFont(font)
        self.filterIndexButton.setObjectName("filterIndexButton")
        self.filterIndexButton.setEnabled(False)
        self.filterIndexButton.clicked.connect(self.clickFilterIndexButton)

        # warning box for path error
        self.noPathBox = QtWidgets.QMessageBox(self.centralwidget)
        self.noPathBox.setIcon(QtWidgets.QMessageBox.Warning)
        self.noPathBox.setText('Folder path not found!')
        self.noPathBox.setWindowTitle("Path Error")

        # warning box for no ppl file
        self.noPplFileBox = QtWidgets.QMessageBox(self.centralwidget)
        self.noPplFileBox.setIcon(QtWidgets.QMessageBox.Warning)
        self.noPplFileBox.setText('.ppl file not found')
        self.noPplFileBox.setWindowTitle("No File Error")

        # warning box for no variable
        self.noVarBox = QtWidgets.QMessageBox(self.centralwidget)
        self.noVarBox.setIcon(QtWidgets.QMessageBox.Warning)
        self.noVarBox.setWindowTitle("No Variable Error")

        # warning box for no index
        self.noIndexBox = QtWidgets.QMessageBox(self.centralwidget)
        self.noIndexBox.setIcon(QtWidgets.QMessageBox.Warning)
        self.noIndexBox.setWindowTitle("No Index Error")

        self.boxPA = QtWidgets.QMessageBox(self.centralwidget)
        self.boxPA.setIcon(QtWidgets.QMessageBox.Information)
        self.boxPA.setText(f"Convert unit?")
        self.boxPA.setWindowTitle("Unit Conversion")
        self.buttonBARG = self.boxPA.addButton('Convert to BARG', QtWidgets.QMessageBox.ActionRole)
        self.buttonBARA = self.boxPA.addButton('Convert to BARA', QtWidgets.QMessageBox.ActionRole)
        self.buttonATM = self.boxPA.addButton('Convert to ATM', QtWidgets.QMessageBox.ActionRole)
        self.buttonPSIG = self.boxPA.addButton('Convert to PSIG', QtWidgets.QMessageBox.ActionRole)
        self.buttonPSIA = self.boxPA.addButton('Convert to PSIA', QtWidgets.QMessageBox.ActionRole)
        self.buttonSkipPA = self.boxPA.addButton('Skip', QtWidgets.QMessageBox.ActionRole)

        self.boxM3S = QtWidgets.QMessageBox(self.centralwidget)
        self.boxM3S.setIcon(QtWidgets.QMessageBox.Information)
        self.boxM3S.setText(f"Convert unit?")
        self.boxM3S.setWindowTitle("Unit Conversion")
        self.buttonM3H = self.boxM3S.addButton('Convert to M3/H', QtWidgets.QMessageBox.ActionRole)
        self.buttonM3D = self.boxM3S.addButton('Convert to M3/D', QtWidgets.QMessageBox.ActionRole)
        self.buttonSkipM3S = self.boxM3S.addButton('Skip', QtWidgets.QMessageBox.ActionRole)

        self.boxSM3S = QtWidgets.QMessageBox(self.centralwidget)
        self.boxSM3S.setIcon(QtWidgets.QMessageBox.Information)
        self.boxSM3S.setText(f"Convert unit?")
        self.boxSM3S.setWindowTitle("Unit Conversion")
        self.buttonMMSCFD = self.boxSM3S.addButton('Convert to MMSCFD', QtWidgets.QMessageBox.ActionRole)
        self.buttonSTBD = self.boxSM3S.addButton('Convert to STBD', QtWidgets.QMessageBox.ActionRole)
        self.buttonSM3H = self.boxSM3S.addButton('Convert to SM3/H', QtWidgets.QMessageBox.ActionRole)
        self.buttonSM3D = self.boxSM3S.addButton('Convert to SM3/D', QtWidgets.QMessageBox.ActionRole)
        self.buttonSkipSM3S = self.boxSM3S.addButton('Skip', QtWidgets.QMessageBox.ActionRole)
        
        self.label_5 = QtWidgets.QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(10, 410, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.label_5.setFont(font)
        self.label_5.setObjectName("label_5")
        
        self.label_6 = QtWidgets.QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(10, 325, 121, 21))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.label_6.setFont(font)
        self.label_6.setText("Select timestep(s) (in minutes):")
        self.label_6.adjustSize()
        self.label_6.setObjectName("label_6")

        # Slider is connected to function until folder path is inputed
        self.filterTimeMin = QtWidgets.QSlider(self.centralwidget)
        self.filterTimeMin.setGeometry(QtCore.QRect(50, 360, 171, 16))
        self.filterTimeMin.setOrientation(QtCore.Qt.Horizontal)
        self.filterTimeMin.setObjectName("filterTimeMin")
        
        self.filterTimeMax = QtWidgets.QSlider(self.centralwidget)
        self.filterTimeMax.setGeometry(QtCore.QRect(50, 380, 171, 16))
        self.filterTimeMax.setOrientation(QtCore.Qt.Horizontal)
        self.filterTimeMax.setObjectName("filterTimeMax")
        
        self.label_7 = QtWidgets.QLabel(self.centralwidget)
        self.label_7.setGeometry(QtCore.QRect(10, 340, 91, 21))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setUnderline(True)
        self.label_7.setFont(font)
        self.label_7.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.label_7.setWordWrap(True)
        self.label_7.setObjectName("label_7")
        
        self.label_8 = QtWidgets.QLabel(self.centralwidget)
        self.label_8.setGeometry(QtCore.QRect(10, 360, 31, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_8.setFont(font)
        self.label_8.setObjectName("label_8")
        
        self.label_9 = QtWidgets.QLabel(self.centralwidget)
        self.label_9.setGeometry(QtCore.QRect(10, 380, 31, 16))
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_9.setFont(font)
        self.label_9.setObjectName("label_9")

        # Editing is disabled until folder path is inputed
        self.timestepEdit = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.timestepEdit.setGeometry(QtCore.QRect(230, 330, 291, 71))
        font = QtGui.QFont()
        font.setPointSize(9)
        self.timestepEdit.setFont(font)
        self.timestepEdit.setReadOnly(True)
        self.timestepEdit.setObjectName("timestepEdit")

        # timestepButton is disabled until timestepEdit is filled        
        self.timestepButton = QtWidgets.QPushButton(self.centralwidget)
        self.timestepButton.setGeometry(QtCore.QRect(530, 370, 86, 23))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.timestepButton.setFont(font)
        self.timestepButton.setObjectName("timestepButton")
        self.timestepButton.setEnabled(False)
        self.timestepButton.clicked.connect(self.clickTimestepButton)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "OLGA Extractor"))
        self.label.setText(_translate("MainWindow", "Folder path:"))
        self.pathButton.setText(_translate("MainWindow", "Display File(s)"))
        self.readingFileLabel.setText(_translate("MainWindow", "Available .ppl file(s):"))
        self.label_3.setText(_translate("MainWindow", "Available index(es):"))
        self.selectIndexButton.setText(_translate("MainWindow", "Select Index"))
        self.label_4.setText(_translate("MainWindow", "Select index(es):"))
        self.extractButton.setText(_translate("MainWindow", "Extract!"))
        self.exportButton.setText(_translate("MainWindow", "Export to Excel"))
        self.label_2.setText(_translate("MainWindow", "Select Variable(s):"))
        self.filterIndexButton.setText(_translate("MainWindow", "Filter Index"))
        self.label_5.setText(_translate("MainWindow", "Status:"))
        self.label_7.setText(_translate("MainWindow", "Filter Timestep"))
        self.label_8.setText(_translate("MainWindow", "Min:"))
        self.label_9.setText(_translate("MainWindow", "Max:"))
        self.timestepButton.setText(_translate("MainWindow", "Select Timestep"))
        self.fileMenu.setTitle(_translate("MainWindow", "File"))
        self.helpMenu.setTitle(_translate("MainWindow", "Help"))
        self.saveTempMenu.setText(_translate("MainWindow", "Save template"))
        self.howTo.setText(_translate("MainWindow", "How to use"))
        
    def enablePathButton(self):
        self.pathButton.setEnabled(bool(self.pathEdit.text()))

    def enableFilterIndex(self):
        self.filterIndexButton.setEnabled(bool(self.variableEdit.text()))

    def enableSelectIndex(self):
        self.selectIndexButton.setEnabled(bool(self.indexEdit.text()))
        
    def clickPathButton(self):

        # Reset all text box
        self.displayFile.clear()
        self.displayIndex.clear()
        self.timestepEdit.clear()
        self.displayStatus.clear()

        # Reset selected index
        self.indexIn = []
        self.timeIn = []

        # Enable save template action
        self.saveTempMenu.setEnabled(True)
        
        path = self.pathEdit.text()

        # If path error, function is not continued
        try:
            os.chdir(path)
        except:
            self.readingFileLabel.setText("Available .ppl file(s):")
            self.readingFileLabel.adjustSize()
            self.noPathBox.exec_()
            return

        self.path = path

        fileList = os.listdir()
        pplFiles = []

        for file in fileList:
            if file.endswith('.ppl'):
                pplFiles.append(file)

        self.pplFiles = pplFiles

        # If no ppl file, function is not continued
        if not pplFiles:
            self.noPplFileBox.exec_()
            return

        self.readingFileLabel.setText(f'Reading {len(pplFiles)} .ppl file(s) . . .')
        self.readingFileLabel.adjustSize()

        # Enable editing and connect slider
        self.indexEdit.setReadOnly(False)
        self.variableEdit.setReadOnly(False)
        self.filterTimeMin.valueChanged.connect(self.displayTime)
        self.filterTimeMax.valueChanged.connect(self.displayTime)
        self.timestepEdit.setReadOnly(False)

        for pplFile in pplFiles:
            self.displayFile.appendPlainText(f'* {pplFile}')

        self.displayFile.moveCursor(QtGui.QTextCursor.Start)

        size = 0
        bigIndex = 0

        for file in pplFiles:
            if size == 0 or size < os.path.getsize(file):
                size = os.path.getsize(file)
                bigIndex = pplFiles.index(file)

        self.pplIndex = fa.Ppl(pplFiles[bigIndex])

        timeList = list(np.around(np.array(self.pplIndex.time)/60))

        self.filterTimeMin.setMinimum(int(min(timeList)))
        self.filterTimeMin.setMaximum(int(max(timeList)))
        self.filterTimeMax.setMinimum(int(min(timeList)))
        self.filterTimeMax.setMaximum(int(max(timeList)))

        self.timeList = timeList

        self.varList = []
        for i in self.pplIndex.profiles.keys():
            var_i = self.pplIndex.profiles[i].split()[0]
            if var_i not in self.varList:
                self.varList.append(var_i)
        
    def clickFilterIndexButton(self):
        self.displayIndex.clear()

        varIn = self.variableEdit.text()
        var = varIn.upper().replace(',',' ').split()

        noVar = []
        for v in var:
            if v in self.varList:
                filterVar = self.pplIndex.filter_data(v)
                for index in filterVar.keys():
                    toDisplayIndex = f'{index}: {filterVar[index][0:-2]}'
                    self.displayIndex.appendPlainText(toDisplayIndex)
            else:
                noVar.append(v)

        self.displayIndex.moveCursor(QtGui.QTextCursor.Start)

        if len(noVar) != 0:
            noVarWrite = ''
            for v in noVar:
                noVarWrite += v
                if v != noVar[-1]:
                    noVarWrite += ', '
            self.noVarBox.setText(f'Cannot find the following variable(s): {noVarWrite}')
            self.noVarBox.exec_()

    def clickSelectIndexButton(self):
        self.displayStatus.clear()

        # Reset extract button if index button clicked
        self.extractButton.setEnabled(False)

        index = self.indexEdit.text()
        indexIn = index.replace(',',' ').split()

        self.writeIndexStatus = ''
        noIndex = []
        for i in range(len(indexIn)):
            try:
                indexIn[i] = int(indexIn[i])
                self.writeIndexStatus += f'{indexIn[i]}: {self.pplIndex.profiles[indexIn[i]]}'
            except:
                noIndex.append(indexIn[i])

        self.displayStatus.appendPlainText(f'File path: {self.path}\n')

        if not self.writeIndexStatus:
            self.displayStatus.appendPlainText('No index to be extracted!\n')
        else:
            self.displayStatus.appendPlainText('Index(es) to be extracted:')
            self.displayStatus.appendPlainText(self.writeIndexStatus)
            self.displayStatus.appendPlainText('Timestep button enabled. Please select timestep.')
            self.timestepButton.setEnabled(True)
            
        if len(noIndex) != 0:
            writeNoIndex = ''
            for index_i in noIndex:
                writeNoIndex += str(index_i)
                if index_i != noIndex[-1]:
                    writeNoIndex = ', '
            self.noIndexBox.setText(f'Cannot find the folowing index(es): {writeNoIndex}')
            self.noIndexBox.exec_()
            
        self.indexIn = indexIn

    def displayTime(self):
        self.timestepEdit.clear()
        minTimeValue = self.filterTimeMin.value()
        maxTimeValue = self.filterTimeMax.value()

        minTimeIndex = 0
        for time in self.timeList:
            if minTimeValue <= time:
                minTimeIndex = self.timeList.index(time)
                break

        maxTimeIndex = 0
        for time in self.timeList:
            if maxTimeValue <= time:
                maxTimeIndex = self.timeList.index(time)-1
                break

        displayTimeList = self.timeList[minTimeIndex:maxTimeIndex]
        writeTime = ''

        for time in displayTimeList:
            writeTime += str(time)
            if time != displayTimeList[-1]:
                writeTime += ', '

        self.timestepEdit.appendPlainText(writeTime)

    def clickTimestepButton(self):
        self.displayStatus.clear()

        timeInput = self.timestepEdit.toPlainText()
        timeInput = timeInput.replace(',',' ').split()

        timeFloat = []
        for time in timeInput:
            try:
                timeFloat.append(float(time))
            except:
                continue

        timeIn = []
        for time in timeFloat:
            try:
                timeIn.append(self.timeList.index(time))
            except:
                continue

        self.displayStatus.appendPlainText(f'File path: {self.path}\n')

        if not self.writeIndexStatus:
            self.displayStatus.appendPlainText('No index to be extracted!\n')
        else:
            self.displayStatus.appendPlainText('Index(es) to be extracted:')
            self.displayStatus.appendPlainText(self.writeIndexStatus)

        self.displayStatus.appendPlainText('Selected timestep(s) (in minutes):')

        writeTime = ''
        for time in timeFloat:
            writeTime += str(time)
            if time != timeFloat[-1]:
                writeTime += ', '
        self.extractButton.setEnabled(True)

        self.displayStatus.appendPlainText(writeTime)
        self.displayStatus.moveCursor(QtGui.QTextCursor.Start)

        self.timeIn = timeIn
        self.writeTime = writeTime

    def clickExtractButton(self):
        self.displayStatus.appendPlainText('\nExtracting . . .')

        for i in self.indexIn:
            try:
                self.pplIndex.extract(i)
            except KeyError:
                self.displayStatus.appendPlainText(f'Index {i} is not available!')
                self.indexIn.remove(i)
                
        dfDict = {}
        unitRE = re.compile(r'(\(.*?\))')

        for file in self.pplFiles:
            indexDict = {}
            for index_i in self.indexIn:
                tempDict = {}

                tempDict.setdefault('data',pd.DataFrame())

                tempDict.setdefault('fileName',file)

                varName = self.pplIndex.label[index_i].split()[0]
                tempDict.setdefault('varName',varName)

                branchName = self.pplIndex._define_branch(index_i)
                tempDict.setdefault('branchName',branchName)

                unit = unitRE.search(self.pplIndex.label[index_i]).group(1)
                tempDict.setdefault('unit',unit)

                indexDict.setdefault(index_i,tempDict)
            dfDict.setdefault(file,indexDict)
        self.dfDict = dfDict

        unitDict = {}
        for index_i in self.indexIn:
            tempDict = {}

            varName = self.pplIndex.label[index_i].split()[0]
            tempDict.setdefault('varName',varName)

            branchName = self.pplIndex._define_branch(index_i)
            tempDict.setdefault('branchName',branchName)

            unit = unitRE.search(self.pplIndex.label[index_i]).group(1)
            tempDict.setdefault('unit',unit)
            
            unitDict.setdefault(index_i,tempDict)
        self.unitDict = unitDict

        self.start_time = tm.time()
        self.dfDictQue = queue.Queue()
        self.getExtractThread = extractThread(self.pplFiles, self.indexIn, self.timeIn, self.dfDict, self.dfDictQue)
        self.getExtractThread.myStatus.connect(self.extractStatus)
        self.getExtractThread.finished.connect(self.extractDone)
        self.getExtractThread.start()
        
    def extractStatus(self, fileExtracted):
        self.displayStatus.appendPlainText(f'{fileExtracted} has been extracted.')

    def extractDone(self):
        self.end_time = tm.time()
        extractDuration = round(self.end_time - self.start_time)
        self.displayStatus.appendPlainText(f'Data is extracted in {extractDuration} seconds.\n')
        self.unitConversion()
        self.exportButton.setEnabled(True)

    def unitConversion(self):
        self.displayStatus.appendPlainText('Unit converting . . .')

        # noConv variable will be 0 if no PA, M3/S, or SM3/S units
        noConv = 0        
        for index_i in self.unitDict.keys():
            if self.unitDict[index_i]['unit'] == '(PA)':
                noConv += 1
                self.convertPA(index_i)
            elif self.unitDict[index_i]['unit'] == '(M3/S)':
                noConv += 1
                self.convertM3S(index_i)
            elif self.unitDict[index_i]['unit'] == '(SM3/S)':
                noConv += 1
                self.convertSM3S(index_i)

        if noConv == 0:
            self.displayStatus.appendPlainText('No unit converted.\n')

    def convertPA(self,index_i):
        unitPA = {self.buttonBARG:{'times':1e-5,'add':-1.01325,'unit':'(BARG)'},
                  self.buttonBARA:{'times':1e-5,'add':0,'unit':'(BARA)'},
                  self.buttonATM:{'times':9.86923e-6,'add':0,'unit':'(ATM)'},
                  self.buttonPSIA:{'times':0.000145038,'add':0,'unit':'(PSIA)'},
                  self.buttonPSIG:{'times':0.000145038,'add':-14.6959,'unit':'(PSIG)'}}

        self.boxPA.setText(f"Convert unit for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']}? \
Current unit: {self.unitDict[index_i]['unit']}")
        self.boxPA.exec_()
        target = self.boxPA.clickedButton()

        if target != self.buttonSkipPA:
            for file in self.dfDict.keys():
                self.dfDict[file][index_i]['unit'] = unitPA[target]['unit']
                for col in self.dfDict[file][index_i]['data'].columns:
                    if col != 'Pipeline Length (m)':
                        self.dfDict[file][index_i]['data'][col] = self.dfDict[file][index_i]['data'][col]*unitPA[target]['times']+unitPA[target]['add']
            self.displayStatus.appendPlainText(f"Unit for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']} has been converted")
        else:
            self.displayStatus.appendPlainText(f"Unit is not converted for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']}")

    def convertM3S(self,index_i):
        unitM3S = {self.buttonM3H:{'times':3600,'add':0,'unit':'(M3/H)'},
                   self.buttonM3D:{'times':86400,'add':0,'unit':'(M3/D)'}}

        self.boxM3S.setText(f"Convert unit for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']}? \
Current unit: {self.unitDict[index_i]['unit']}")
        self.boxM3S.exec_()
        target = self.boxM3S.clickedButton()

        if target != self.buttonSkipM3S:
            for file in self.dfDict.keys():
                self.dfDict[file][index_i]['unit'] = unitM3S[target]['unit']
                for col in self.dfDict[file][index_i]['data'].columns:
                    if col != 'Pipeline Length (m)':
                        self.dfDict[file][index_i]['data'][col] = self.dfDict[file][index_i]['data'][col]*unitM3S[target]['times']+unitM3S[target]['add']
            self.displayStatus.appendPlainText(f"Unit for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']} has been converted")
        else:
            self.displayStatus.appendPlainText(f"Unit is not converted for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']}")

    def convertSM3S(self,index_i):
        unitSM3S = {self.buttonMMSCFD:{'times':3.05119333341455,'add':0,'unit':'(MMSCFD)'},
                    self.buttonSTBD:{'times':543439.584,'add':0,'unit':'(STBD)'},
                    self.buttonSM3H:{'times':3600,'add':0,'unit':'(SM3/H)'},
                    self.buttonSM3D:{'times':86400,'add':0,'unit':'(SM3/D)'}}

        self.boxSM3S.setText(f"Convert unit for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']}? \
Current unit: {self.unitDict[index_i]['unit']}")
        self.boxSM3S.exec_()
        target = self.boxSM3S.clickedButton()

        if target != self.buttonSkipSM3S:
            for file in self.dfDict.keys():
                self.dfDict[file][index_i]['unit'] = unitSM3S[target]['unit']
                for col in self.dfDict[file][index_i]['data'].columns:
                    if col != 'Pipeline Length (m)':
                        self.dfDict[file][index_i]['data'][col] = self.dfDict[file][index_i]['data'][col]*unitSM3S[target]['times']+unitSM3S[target]['add']
            self.displayStatus.appendPlainText(f"Unit for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']} has been converted")
        else:
            self.displayStatus.appendPlainText(f"Unit is not converted for {self.unitDict[index_i]['varName']}_\
{self.unitDict[index_i]['branchName']}")

    def clickExportButton(self):
        self.displayStatus.appendPlainText(f'\nWriting results to excel . . .')
        curTime = datetime.now().strftime("%d-%m-%Y_%H-%M")
        resultsFile = f'ProfilePlot_{curTime}.xlsx'

        self.startWrite_time = tm.time()
        self.getWriteThread = writeExcelThread(self.dfDict, resultsFile)
        self.getWriteThread.finished.connect(self.writeDone)
        self.getWriteThread.start()
        
    def writeDone(self):
        self.end_time = tm.time()
        writingTime = round(self.end_time - self.start_time)
        self.displayStatus.appendPlainText(f'Results is written in {writingTime} seconds.')

    def saveTemplate(self):
        if not self.indexIn:
            self.noIndexBox.setText('Selected index is empty')
            self.noIndexBox.exec_()
            return
        elif not self.timeIn:
            self.noIndexBox.setText('Selected timestep is empty')
            self.noIndexBox.exec_()
            return
        
        tempName, okPressed = QtWidgets.QInputDialog.getText(None,
                                                             "Save Template",
                                                             "Input template name:",
                                                             QtWidgets.QLineEdit.Normal,
                                                             "")

        if okPressed and tempName != '':
            tempFile = open(f"{tempName}.txt", 'w')

            tempWrite = ''
            tempTimeWrite = ''

            for index in self.indexIn:
                tempWrite += str(index)
                if index != self.indexIn[-1]:
                    tempWrite += ', '

            for time in self.timeIn:
                tempTimeWrite += str(time)
                if time != self.timeIn[-1]:
                    tempTimeWrite += ', '

            tempFile.write("Please copy the following VARIABLE INDEX:\n")
            tempFile.write(tempWrite)
            tempFile.write("\n\nPlease copy the following TIME INDEX:\n")
            tempFile.write(tempTimeWrite)
            tempFile.write('\n\nNotes:')
            tempFile.write('\n\n**VARIABLE INDEX**\n')
            tempFile.write(self.writeIndexStatus)
            tempFile.write('\n\n**TIME INDEX**\n')
            tempFile.write(self.writeTime)
            tempFile.close()

    def howToUse(self):
        self.help = helpWindow()
        self.help.show()
        #self.hide()

class extractThread(QtCore.QThread):
    def __init__(self,pplFiles,indexIn,timeIn,dfDict,dfDictQue):
        super().__init__()
        self.pplFiles = pplFiles
        self.indexIn = indexIn
        self.timeIn = timeIn
        self.dfDict = dfDict
        self.dfDictQue = dfDictQue

    myStatus = QtCore.pyqtSignal(str)
    def run(self):
        for pplFile in self.pplFiles:
            ppl = fa.Ppl(pplFile)
            for index_i in self.indexIn:
                ppl.extract(index_i)
                pplGeo = pd.DataFrame(ppl.data[index_i][0],columns=['Pipeline Length (m)'])

                dataDF = pd.DataFrame()
                noData = 0
                for time in self.timeIn:
                    try:
                        colTitle = f"{round(ppl.time[time]/60)} min"
                        pplData = pd.DataFrame(ppl.data[index_i][1][time],columns=[colTitle])
                        dataDF = pd.concat([dataDF,pplData],axis=1,sort=False)
                    except IndexError:
                        noData += 1

                if noData == 0 or noData < len(self.timeIn):
                    resultDF = pd.concat([pplGeo,dataDF],axis=1,sort=False)
                    self.dfDict[pplFile][index_i]['data'] = pd.concat([self.dfDict[pplFile][index_i]['data'],resultDF],axis=1,sort=False)
                else:
                    self.dfDict[pplFile].pop(index_i)
            self.myStatus.emit(pplFile)
        self.dfDictQue.put(self.dfDict)

class writeExcelThread(QtCore.QThread):
    def __init__(self, dfDict, resultsFile):
        super().__init__()
        self.dfDict = dfDict
        self.resultsFile = resultsFile

    def run(self):
        for file in self.dfDict.keys():
            writeDF = pd.DataFrame()
            sheetLabel = f'ppl File {list(self.dfDict.keys()).index(file)+1}'
            for index_i in self.dfDict[file].keys():
                labelDF = pd.DataFrame()
                spaceDF = pd.DataFrame()
                dataLabel = f"File Name: {self.dfDict[file][index_i]['fileName']}\n\
Variable: {self.dfDict[file][index_i]['varName']}\n\
Branch: {self.dfDict[file][index_i]['branchName']}\n\
Unit: {self.dfDict[file][index_i]['unit']}"
                labelDF[dataLabel]=''
                spaceDF['']=''
                writeDF = pd.concat([writeDF,labelDF,self.dfDict[file][index_i]['data'],spaceDF],axis=1,sort=False)

            if self.resultsFile not in os.listdir():
                with pd.ExcelWriter(self.resultsFile) as writer:
                    writeDF.to_excel(writer, sheet_name = sheetLabel)
            else:
                with pd.ExcelWriter(self.resultsFile, mode='a') as writer:
                    writeDF.to_excel(writer, sheet_name = sheetLabel)

            exFile = openpyxl.load_workbook(self.resultsFile)
            sheet = exFile[sheetLabel]
            labelRE = re.compile(f'File Name: (.*)\nVariable: (.*)\nBranch: (.*)\nUnit: (.*)')

            for col in range(1,sheet.max_column):
                if not sheet.cell(1, col).value:    # Format data label
                    labelCol = get_column_letter(col+1)
                    labelCell = f'{labelCol}1'
                    labelMerge = f'{labelCol}1:{labelCol}4'
                    label = sheet.cell(1, col+1).value
                    sheet[labelCell].font = Font(bold=True,color="00FF0000")
                    sheet.merge_cells(labelMerge)
                    sheet.cell(1, col+1).alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
                    sheet.column_dimensions[labelCol].width = 45

                    # Save y_axis title from data label ( varName_branchName (unit) )
                    
                    search = labelRE.findall(sheet.cell(1, col+1).value)
                    y_axis_title = f'{search[0][1]} {search[0][3]}'
                    chartTitle = ' '.join(search[0][1:3])

                if sheet.cell(1, col).value == 'Pipeline Length (m)':
                    chart = ScatterChart()
                    chart.title = chartTitle
                    chart.style = 3
                    chart.y_axis.title = y_axis_title
                    chart.x_axis.title = 'Pipeline Length (m)'
                    xvalues = Reference(sheet, min_col=col, min_row=2, max_row=sheet.max_row)
                elif sheet.cell(1, col).value and sheet.cell(1, col).value != label:
                    values = Reference(sheet, min_col=col, min_row=2, max_row=sheet.max_row)
                    dataTitle = sheet.cell(row=1, column=col).value
                    series = Series(values, xvalues, title=dataTitle)
                    chart.series.append(series)

                    if not sheet.cell(1,col+1).value:
                        sheet.add_chart(chart, f'{labelCol}5')
                    
            exFile.save(self.resultsFile)

class helpWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("How to use")
        self.setFixedSize(500, 400)
        self.label = QtWidgets.QLabel ("PPL Transient Extractor - How to Use", self)
        self.label.move(10,10)
        labelFont = QtGui.QFont()
        labelFont.setPointSize(9)
        labelFont.setBold(True)
        labelFont.setWeight(75)
        self.label.setFont(labelFont)
        self.label.adjustSize()

        self.howToUse = QtWidgets.QPlainTextEdit(self)
        self.howToUse.setGeometry(QtCore.QRect(10, 30, 480, 350))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.howToUse.setFont(font)
        self.howToUse.setReadOnly(True)

        helpText = 'This program will extract results from one or more OLGA .ppl file.\n\n\
How to use:\n\n\
1. Input folder path where the .ppl file(s) is saved in "Folder path" and click "Display File(s)" button\n\n\
WARNING: PLEASE MAKE SURE THAT ALL PPL FILES IN THE FOLDER PATH ARE GENERATED FROM SIMULATION MODELS WHICH ARE THE SAME IN TERMS OF BRANCHES AND OUTPUT VARIABLE CONFIGURATION\n\n\
2. After "Display File(s)" button has been clicked, program will display all available .ppl file(s) in the folder path\n\n\
3. Basically, OLGA .ppl file separates the simulation results based on index. This index is associated to a specific variable (e.g. pressure, temperature, gas velocity) and a specific branch (e.g. main flowline, riser).\n\n\
3.1. If user does not know which index to be extracted:\n\n\
3.1.1. User can see the available indexes of one variable or more by filling in the "Select Variable(s)" box with the variable symbol (e.g. PT for pressure, TM for temperature). If the variable is more than one, separate them by comma.\n\
3.1.2. User then can select one or more index to be extracted by filling in the "Select index(es)" box with the selected index(es). If the selected index is more than one, separate them by comma. Then, click the "Select" button.\n\n\
3.2. If user has a template of index to be extracted, user can directly filling in the "Select index(es)" box with the index(es) that are saved in the template. Then, click the "Select" button.\n\n\
4. "Status" box will display the inputed folder path and the selected index(es). "Status" box then will tell user to select timestep(s) of the results to be extracted.\n\n\
5. In the "Select timestep(s) (in minutes)" box, user can manually fill-in the selected timestep(s). Or, user can see the available timestep(s) by dragging the "Min" and "Max" sliders. This filter will display the available timestep(s) in the box and user can edit it manually.\n\n\
6. User can click "Extract!" button to extract the selected index(es) at the selected timestep(s) which are displayed in the "Status" box.\n\n\
WARNING: EXTRACTED DATA WILL BE OVERWRITTEN ONCE THE "Extract!" BUTTON IS CLICKED. PLEASE MAKE SURE THAT THE SELECTED INDEX(ES) AND TIMESTEP(S) ARE ALREADY CORRECT BEFORE EXTRACTING. TO MODIFY THE SELECTED INDEX(ES), PLEASE REPEAT FROM STEP 3. TO MODIFY ONLY THE SELECTED TIMESTEP(S), PLEASE REPEAT FROM STEP 5.\n\n\
7. Once the extraction has been finished (see "Status" box for extraction status), program will display a pop-up message if there are some units that can be extracted (i.e. PA, M3/S, or SM3/S).\n\n\
8. To write the extracted data to an excel file, click "Export to Excel" button.\n\n\
9. The selected index can be saved into a .txt file by clicking File > Save template. The program will ask user to enter the file template name.'

        self.howToUse.insertPlainText(helpText)
        self.howToUse.moveCursor(QtGui.QTextCursor.Start)
            
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
